#! OWL semantics inference rules.

## Functional property.
owl:FunctionalProperty {
	?c rdf:type owl:FunctionalProperty .
	?x ?c ?y1 .
	?x ?c ?y2 .
} => {
	?y1 = ?y2 !
}

## Inverse functional property.
owl:InverseFunctionalProperty {
	?c rdf:type owl:InverseFunctionalProperty .
	?x1 ?c ?y .
	?x2 ?c ?y .
} => {
	?x1 = ?x2 !
}

## Symmetric property.
owl:SymmetricProperty {
	?c rdf:type owl:SymmetricProperty .
	?x ?c ?y .
} => {
	?y ?c ?x .
}

owl:TransitiveProperty {
	?c rdf:type owl:TransitiveProperty .
	?x ?c ?y .
	?y ?c ?z .
} => {
	?x ?c ?z .
}

owl:equivalentClass {
	?x owl:equivalentClass ?y .
	?a rdf:type ?x .
} => {
	?a rdf:type ?y .
}

owl:disjointWith {
	?x owl:disjointWith ?y .
	?a rdf:type ?x .
} => {
	?a !rdf:type ?y .
}

owl:equivalentProperty {
	?x owl:equivalentProperty ?y .
	?u ?x ?v .
} => {
	?u ?y ?v .
}

owl:inverseOf {
	?x owl:inverseOf ?y .
	?u ?x ?v .
} => {
	?v ?y ?u .
}

owl:sameAs {
	?x owl:sameAs ?y .
} => {
	?x = ?y .
}

owl:differentFrom {
	?x owl:differentFrom ?y .
} => {
	?x != ?y .
}

## Complement.
owl:complementOf {
	#owl:omplementOf1 {
		?x owl:complementOf ?y .
		?v rdf:type ?x .
	} => {
		?v !rdf:type ?y .
	}

	#owl:complementOf2 {
		?x owl:complementOf ?y .
		?v !rdf:type ?y .
	} => {
		?v rdf:type ?x .
	}
}

# Class union.
owl:unionOf {
	?x owl:unionOf ?list .
	?list rdf:rest*/rdf:first ?y .
	?v rdf:type ?y .
} => {
	?v rdf:type ?x .
}

## Class intersection.
owl:intersectionOf {
	#owl:intersectionOf1 {
		?x owl:intersectionOf ?list .
		?v #owl:inIntersectionOf ?list .
	} => {
		?v rdf:type ?x .
	}

	#owl:inIntersectionOf1 {
		?list rdf:first ?c .
		?list rdf:rest ?rest .
		?v rdf:type ?c .
		?v #owl:inIntersectionOf ?rest .
	} => {
		?v #owl:inIntersectionOf ?list .
	}

	#owl:inIntersectionOf2 {
		# nothing
	} => {
		?v #owl:inIntersectionOf rdf:nil .
	}
}

owl:oneOf {
	?x owl:oneOf ?list .
	?list rdf:rest*/rdf:first ?v .
} => {
	?v rdf:type ?y .
}